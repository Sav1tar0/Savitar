### Problem 1: ACM Team
```python
def acm_team(topic: list[str]) -> list[int]:
    max_topics = 0
    num_teams = 0
    n = len(topic)
    for i in range(n):
        for j in range(i+1, n):
            combined = bin(int(topic[i], 2) | int(topic[j], 2)).count('1')
            if combined > max_topics:
                max_topics = combined
                num_teams = 1
            elif combined == max_topics:
                num_teams += 1
    return [max_topics, num_teams]
```

### Problem 2: Alternate
```python
def alternate(s: str) -> int:
    unique_chars = set(s)
    max_len = 0
    for a in unique_chars:
        for b in unique_chars:
            if a == b:
                continue
            filtered = [c for c in s if c == a or c == b]
            if all(filtered[i] != filtered[i+1] for i in range(len(filtered)-1)):
                max_len = max(max_len, len(filtered))
    return max_len
```

### Problem 6: Balanced Sums
```python
def balancedSums(arr: list[int]) -> str:
    total = sum(arr)
    left_sum = 0
    for i, num in enumerate(arr):
        if left_sum == total - left_sum - num:
            return "YES"
        left_sum += num
    return "NO"
```

### Problem 7: Beautiful Days
```python
def beautifulDays(i: int, j: int, k: int) -> int:
    count = 0
    for day in range(i, j+1):
        reversed_day = int(str(day)[::-1])
        if abs(day - reversed_day) % k == 0:
            count += 1
    return count
```

### Problem 9: Caesar Cipher
```python
def caesarCipher(s: str, k: int) -> str:
    result = []
    k = k % 26
    for char in s:
        if char.isupper():
            result.append(chr((ord(char) - ord('A') + k) % 26 + ord('A')))
        elif char.islower():
            result.append(chr((ord(char) - ord('a') + k) % 26 + ord('a')))
        else:
            result.append(char)
    return ''.join(result)
```

### Problem 12: Can Form Palindrome
```python
def can_form_palindrome(s: str) -> str:
    from collections import defaultdict
    freq = defaultdict(int)
    for char in s:
        freq[char] += 1
    odd_count = sum(1 for count in freq.values() if count % 2 != 0)
    return "YES" if odd_count <= 1 else "NO"
```

### Problem 18: Chocolate Feast
```python
def chocolateFeast(n: int, c: int, m: int) -> int:
    chocolates = n // c
    wrappers = chocolates
    while wrappers >= m:
        new_chocolates = wrappers // m
        chocolates += new_chocolates
        wrappers = wrappers % m + new_chocolates
    return chocolates
```

### Problem 19: Closest Numbers
```python
def closestNumbers(arr: list[int]) -> list[int]:
    arr.sort()
    min_diff = float('inf')
    result = []
    for i in range(1, len(arr)):
        diff = arr[i] - arr[i-1]
        if diff < min_diff:
            min_diff = diff
            result = [arr[i-1], arr[i]]
        elif diff == min_diff:
            result.extend([arr[i-1], arr[i]])
    return result
```

### Problem 21: Compare Bubble and Insertion Sort Swaps
```python
def compare_swaps_bubble_insertion_sort(arr):
    bubble_swaps = 0
    insertion_swaps = 0
    n = len(arr)
    
    # Bubble sort swaps
    bubble_arr = arr.copy()
    for i in range(n):
        for j in range(n-1):
            if bubble_arr[j] > bubble_arr[j+1]:
                bubble_arr[j], bubble_arr[j+1] = bubble_arr[j+1], bubble_arr[j]
                bubble_swaps += 1
    
    # Insertion sort swaps
    insertion_arr = arr.copy()
    for i in range(1, len(insertion_arr)):
        key = insertion_arr[i]
        j = i-1
        while j >=0 and key < insertion_arr[j]:
            insertion_arr[j+1] = insertion_arr[j]
            insertion_swaps += 1
            j -= 1
        insertion_arr[j+1] = key
    
    return "insertion" if insertion_swaps <= bubble_swaps else "bubble"
```

### Problem 24: Count Special Problems
```python
def count_special_problems(n: int, k: int, arr: list[int]) -> int:
    special = 0
    page = 1
    for chapter in arr:
        problems = range(1, chapter + 1)
        for i in range(0, len(problems), k):
            chunk = problems[i:i+k]
            if page in chunk:
                special += 1
            page += 1
    return special
```

### Problem 30: Find Poisoned Duration
```python
def findPoisonedDuration(timeSeries: list[int], duration: int) -> int:
    if not timeSeries:
        return 0
    total = 0
    for i in range(len(timeSeries)-1):
        total += min(timeSeries[i+1] - timeSeries[i], duration)
    return total + duration
```

### Problem 32: Find Common Strings with Least Index Sum
```python
def find_common_strings_with_least_index_sum(list1: list[str], list2: list[str]) -> list[str]:
    common = set(list1) & set(list2)
    if not common:
        return []
    min_sum = float('inf')
    result = []
    for word in common:
        current_sum = list1.index(word) + list2.index(word)
        if current_sum < min_sum:
            min_sum = current_sum
            result = [word]
        elif current_sum == min_sum:
            result.append(word)
    return result
```

### Problem 37: Find Length of LCIS
```python
def find_length_of_lcis(nums: list[int]) -> int:
    if not nums:
        return 0
    max_len = 1
    current_len = 1
    for i in range(1, len(nums)):
        if nums[i] > nums[i-1]:
            current_len += 1
            max_len = max(max_len, current_len)
        else:
            current_len = 1
    return max_len
```

### Problem 41: Find Shortest Subarray with Degree
```python
def find_shortest_subarray_with_degree(nums: list[int]) -> int:
    from collections import defaultdict
    left, right, count = {}, {}, defaultdict(int)
    for i, num in enumerate(nums):
        if num not in left:
            left[num] = i
        right[num] = i
        count[num] += 1
    
    degree = max(count.values())
    min_len = float('inf')
    for num in count:
        if count[num] == degree:
            min_len = min(min_len, right[num] - left[num] + 1)
    return min_len
```

### Problem 44: Flood Fill
```python
def flood_fill(image: list[list[int]], sr: int, sc: int, color: int) -> list[list[int]]:
    if image[sr][sc] == color:
        return image
    original_color = image[sr][sc]
    rows, cols = len(image), len(image[0])
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != original_color:
            return
        image[r][c] = color
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    
    dfs(sr, sc)
    return image
```

### Problem 46: Game of Stones
```python
def gameOfStones(n: int) -> str:
    return "First" if n % 7 not in [0, 1] else "Second"
```

### Problem 47: Happy Ladybugs
```python
def happyLadybugs(b: str) -> str:
    from collections import Counter
    count = Counter(b)
    if '_' in count:
        for key, val in count.items():
            if key != '_' and val == 1:
                return "NO"
    else:
        for i in range(len(b)):
            if (i == 0 or b[i] != b[i-1]) and (i == len(b)-1 or b[i] != b[i+1]):
                return "NO"
    return "YES"
```

### Problem 48: How Many Games
```python
def howManyGames(p: int, d: int, m: int, s: int) -> int:
    games = 0
    while s >= p:
        games += 1
        s -= p
        p = max(p - d, m)
    return games
```

### Problem 49: Ice Cream Parlor
```python
def icecreamParlor(m: int, cost: list[int]) -> list[int]:
    seen = {}
    for i, c in enumerate(cost, 1):
        if m - c in seen:
            return [seen[m - c], i]
        seen[c] = i
    return []
```

### Problem 51: Is Valid String Same Occurrence
```python
def isValidStringSameOccurence(s: str) -> str:
    from collections import Counter
    counts = Counter(s)
    freq = Counter(counts.values())
    if len(freq) == 1:
        return "YES"
    if len(freq) == 2:
        k1, k2 = freq.keys()
        if (freq[k1] == 1 and (k1 == 1 or k1 - k2 == 1)) or (freq[k2] == 1 and (k2 == 1 or k2 - k1 == 1)):
            return "YES"
    return "NO"
```

### Problem 57: K Closest
```python
def k_closest(points: list[list[int]], k: int) -> list[list[int]]:
    points.sort(key=lambda p: p[0]**2 + p[1]**2)
    return points[:k]
```

### Problem 61: Largest Permutation
```python
def largestPermutation(k: int, arr: list[int]) -> list[int]:
    n = len(arr)
    pos = {val: i for i, val in enumerate(arr)}
    for i in range(n):
        if k == 0:
            break
        if arr[i] == n - i:
            continue
        swap_pos = pos[n - i]
        pos[arr[i]] = swap_pos
        pos[n - i] = i
        arr[i], arr[swap_pos] = arr[swap_pos], arr[i]
        k -= 1
    return arr
```

### Problem 66: Luck Balance
```python
def luckBalance(k: int, contests: list[list[int]]) -> int:
    important = []
    total = 0
    for luck, importance in contests:
        if importance == 1:
            important.append(luck)
        else:
            total += luck
    important.sort(reverse=True)
    total += sum(important[:k]) - sum(important[k:])
    return total
```

### Problem 73: Migratory Birds
```python
def migratoryBirds(arr):
    from collections import Counter
    count = Counter(arr)
    max_count = max(count.values())
    return min(k for k, v in count.items() if v == max_count)
```

### Problem 76: Min Path Sum
```python
def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, n):
        grid[0][i] += grid[0][i-1]
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]
```

### Problem 77: Minimum Distances
```python
def minimum_distances(a: list[int]) -> int:
    last_seen = {}
    min_dist = float('inf')
    for i, num in enumerate(a):
        if num in last_seen:
            min_dist = min(min_dist, i - last_seen[num])
        last_seen[num] = i
    return min_dist if min_dist != float('inf') else -1
```

### Problem 82: Picking Numbers
```python
def pickingNumbers(a: list[int]) -> int:
    from collections import Counter
    count = Counter(a)
    max_len = 0
    for num in count:
        max_len = max(max_len, count[num] + count.get(num + 1, 0))
    return max_len
```

### Problem 84: Quick Sort Partition
```python
def quick_sort_partition(arr: list[int], low: int, high: int) -> int:
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
```

### Problem 86: Repeated String
```python
def repeatedString(s: str, n: int) -> int:
    count_in_s = s.count('a')
    full_repeats = n // len(s)
    remainder = n % len(s)
    return count_in_s * full_repeats + s[:remainder].count('a')
```

### Problem 89: Reverse Characters in Words
```python
def reverse_characters_in_words(s: str) -> str:
    return ' '.join(word[::-1] for word in s.split(' '))
```

### Problem 96: Super Reduced String
```python
def superReducedString(s: str) -> str:
    stack = []
    for char in s:
        if stack and stack[-1] == char:
            stack.pop()
        else:
            stack.append(char)
    return ''.join(stack) if stack else "Empty String"
```

### Problem 99: Unique Paths with Obstacles
```python
def unique_paths_with_obstacles(obstacleGrid):
    if not obstacleGrid or obstacleGrid[0][0] == 1:
        return 0
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0]*n for _ in range(m)]
    dp[0][0] = 1
    for i in range(m):
        for j in range(n):
            if obstacleGrid[i][j] == 1:
                dp[i][j] = 0
                continue
            if i > 0:
                dp[i][j] += dp[i-1][j]
            if j > 0:
                dp[i][j] += dp[i][j-1]
    return dp[-1][-1]
```




### Problem 101: Valid Palindrome
```python
def valid_palindrome(s: str) -> bool:
    left, right = 0, len(s)-1
    while left < right:
        if s[left] != s[right]:
            skip_left = s[left+1:right+1]
            skip_right = s[left:right]
            return skip_left == skip_left[::-1] or skip_right == skip_right[::-1]
        left += 1
        right -= 1
    return True
```
